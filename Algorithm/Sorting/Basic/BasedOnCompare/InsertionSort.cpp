void InsertionSort(int *a, int n)
{
    // 遍历从第二个元素到最后一个元素
    for (int i = 1; i < n; i++)
    {
        // 选取当前元素作为"键"
        int key = a[i];
        // 从当前元素的前一个元素开始向前遍历
        for (int j = i - 1; j > 0; j--)
        {
            // 如果"键"大于当前元素，将"键"插入到当前元素的后一个位置，并结束内层循环
            if (key > a[j])
            {
                a[j + 1] = key;
                break;
            }
            // 如果"键"不大于当前元素，将当前元素向后移动一位
            a[j + 1] = a[j];
        }
    }
}
//选到的数插到子序列中属于自己的位置,最后扩展到整个序列

// 平均时间复杂度：O(n^2)
// 最优时间复杂度：O(n)
// 最差时间复杂度：O(n^2)

// 空间复杂度: O(1)
// 排序方式: in-place
// 稳定性：稳定